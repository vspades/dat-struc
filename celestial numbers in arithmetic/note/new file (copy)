
%realmax	%Largest floating-point number, (2-eps)*(2^1023)
%Inf		%Infinity--It is generated by dividing a nonzero value by zero, or by evaluating well defined
			%mathematical expressions that overflow, that is, exceed realmax.

%realmax
%the largest "usable" positive real number on the computer.
%this is "approximately" the largest positive real number,
%that can be represented on the computer.
%on most computer 2*realmax returns Inf.
2*realmax


%Caveat emptor!

#Round-off Errors
#Computers cannot add, subtract, multiply, or divide correctly!
(1 + .1) - 1
#we obtain 0.1000 as expected.
(1 + 1.e-40) - 1
#MATLAB returns 0 rather than 1.e-40.
n=input('n= ', 's');	(n.^(1/3)).^3-n

#The reason that (n^(1/3))-n can be nonzero numerically,
#is that MATLAB only stores real numbers,
#to a certain number of digits of accuracy:
log10(1/eps)
#and remember the integer part of this number.
#this is approximately the maximum number of digits of accuracy,
#of any calculation performed in MATLAB.

deg = pi/180; th = 40; 1 - ( cos(th*deg)^2 + sin(th*deg)^2 )
#Obviously, the result is supposed to be zero since,
#from the Pythagorean theorem:
#cos^2(theta) + sin^2(theta) = 1
#in fact, MATLAB has introduced two functions to reduce round-off errors.

x=[0.02 : 0.001 : 0.98]
#should generate the column vector (0.02, 0.021, 0.022, . . . , 0.979, 0.98)
#however, because of round-off errors in storing floating-point numbers,
#there is a possibility that the last element in x will be 0.979.
#this possiblity is much more real in the programming language C.
#for ( i = 0.02; i <= 0.98; i = i + .001 )
#generates successive values of i by adding 0.001 to the preceding value.
#it is possible that when i should have the value 0.98,
#due to round-off errors the value will be slightly larger;
#the condition i <= 0.98 will be false,
#and the loop will not be evaluated when i should be 0.98.
#function <linspace> which avoids this difficulty:
linspace(0.02, 0.98, 0.001)
#an easy "fix" to avoid this possibility is to calculate x by
x=[20:980]/1000




#eps can be calculated by
ep = 1;
while 1 + ep > 1
ep = ep/2;
end
eps = 2*ep
#
